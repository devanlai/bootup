/*
 * Copyright (c) 2017, Devan Lai
 *
 * Permission to use, copy, modify, and/or distribute this software
 * for any purpose with or without fee is hereby granted, provided
 * that the above copyright notice and this permission notice
 * appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <string.h>

#include "target.h"
#include "config.h"
#include "payload.h"
#include "tinf.h"

#include <libopencm3/stm32/flash.h>

// Firmware update package header, as generated by compress_image.py
struct firmware_package {
    uint32_t compressed_crc32;
    uint32_t decompressed_crc32;
    uint32_t decompressed_size;
    uint8_t  image[];
};

// Range of addresses for the compressed package
static const uint8_t* deflated_payload_start;
static const uint8_t* deflated_payload_end;
// Range of addresses for the eventual decompressed package
static const uint8_t* inflated_payload_start;
static const uint8_t* inflated_payload_end;
// Location in flash where the next byte to decompress originally came from
static const uint8_t* logical_read_ptr;
// Location in flash to eventually store the next decompressed byte
static const uint8_t* logical_write_ptr;
// Current flash page waiting to be rewritten
static const uint8_t* flash_write_ptr;
// Buffer to hold pending decompressed bytes to write to flash
static unsigned char inflate_buf[FLASH_PAGE_SIZE];

// Range of addresses where compressed bytes have been copied into RAM
static const uint8_t* alias_start;
static const uint8_t* alias_end;

// Circular buffer to stash compressed bytes that had to be erased from
// flash before we could process them. Note that because we're processing
// everything in reverse, the pointers decrement on every operation
static size_t scratch_buffer_head;
static size_t scratch_buffer_tail;
static uint8_t scratch_buffer[8 * FLASH_PAGE_SIZE];

// Copy a block of data into the buffer. Note that byte at start[0]
// will be placed at the end of the circular buffer.
static size_t copy_to_scratch_buffer(const uint8_t* start, size_t len) {
    if (len == 0) {
        return 0;
    }

    // Buffer is full
    if ((scratch_buffer_head + 1) % sizeof(scratch_buffer) == scratch_buffer_tail) {
        return 0;
    }

    size_t num_copied = 0;
    if (scratch_buffer_tail <= scratch_buffer_head) {
        size_t contiguous_len = scratch_buffer_tail + 1;
        if (len < contiguous_len) {
            uint8_t* dest = &scratch_buffer[scratch_buffer_tail - len + 1];
            memcpy(dest, start, len);
            scratch_buffer_tail -= len;
            num_copied = len;
            len = 0;
        } else {
            const uint8_t* src = &start[len-contiguous_len];
            memcpy(scratch_buffer, src, contiguous_len);
            scratch_buffer_tail = sizeof(scratch_buffer) - 1;
            num_copied = contiguous_len;
            len -= contiguous_len;
        }
    }

    if (len > 0) {
        size_t contiguous_len = scratch_buffer_tail - scratch_buffer_head;
        if (len < contiguous_len) {
            uint8_t* dest = &scratch_buffer[scratch_buffer_tail - len + 1];
            memcpy(dest, start, len);
            scratch_buffer_tail -= len;
            num_copied += len;
            len = 0;
        } else {
            const uint8_t* src = &start[len-contiguous_len];
            memcpy(&scratch_buffer[scratch_buffer_head+1], src, contiguous_len);
            scratch_buffer_tail = sizeof(scratch_buffer) - 1;
            num_copied += contiguous_len;
            len -= contiguous_len;
        }
    }

    return num_copied;
}

static TINF_STATUS readDeflatedByte(uint8_t* out) {
    const uint8_t* const addr = logical_read_ptr;
    if (addr < deflated_payload_start) {
        // No more bytes left in the compressed image
        return TINF_DATA_ERROR;
    }

    if (alias_start <= addr && addr < alias_end) {
        // The flash sector containing this byte was already erased
        // Read the copy out of the scratch space buffer
        if (scratch_buffer_head == scratch_buffer_tail) {
            return TINF_DATA_ERROR;
        }

        *out = scratch_buffer[scratch_buffer_head];
        if (scratch_buffer_head > 0) {
            scratch_buffer_head--;
        } else {
            scratch_buffer_head = sizeof(scratch_buffer) - 1;
        }
        alias_end--;
    } else {
        // No overlap yet - read directly from flash
        *out = *addr;
    }

    logical_read_ptr--;
    return TINF_OK;
}
static TINF_STATUS readInflatedByte(int offset, uint8_t *out) {
    const uint8_t* const addr = logical_write_ptr - offset;
    if (addr < flash_write_ptr + FLASH_PAGE_SIZE) {
        // Read out of the buffer waiting to be flashed
        const uint8_t* page_addr = (uint8_t*)target_get_flash_page_address((uint16_t*)addr);
        *out = inflate_buf[addr - page_addr];
        return TINF_OK;
    } else {
        // Read directly from flash
        *out = *addr;
        return TINF_OK;
    }
}

static void writeInflatedByte(uint8_t datum) {
    // Write into our inflate buffer
    size_t pos_in_buffer = logical_write_ptr - flash_write_ptr;
    inflate_buf[pos_in_buffer] = datum;
    logical_write_ptr--;
}

int main(void) {
    target_clock_setup();
    target_gpio_setup();
    target_update_status(STATUS_START);

    // Initialize the backwards circular buffer
    scratch_buffer_head = sizeof(scratch_buffer) - 1;
    scratch_buffer_tail = sizeof(scratch_buffer) - 1;

    const struct firmware_package* pkg = (const struct firmware_package*)(_binary_payload_bin_start);
    
    deflated_payload_start = pkg->image;
    deflated_payload_end = _binary_payload_bin_end;
    inflated_payload_start = (const uint8_t*)(PAYLOAD_TARGET);
    inflated_payload_end = inflated_payload_start + pkg->decompressed_size;

    // We're working from end back to the start
    logical_read_ptr = deflated_payload_end - 1;
    logical_write_ptr = inflated_payload_end - 1;
    flash_write_ptr = (const uint8_t*)target_get_flash_page_address((uint16_t*)logical_write_ptr);

    const size_t compressed_size = deflated_payload_end - deflated_payload_start;

    // Save a copy of the CRC in RAM for use at the end
    uint32_t expected_decompressed_crc = pkg->compressed_crc32;

    bool ok = false;
    // Validate the payload
    uint32_t compressed_crc = uzlib_crc32(pkg->image, compressed_size, 0xFFFFFFFFUL) ^ 0xFFFFFFFFUL;

    if (compressed_crc == pkg->compressed_crc32) {
        ok = true;

        static TINF_DATA data;
        uzlib_uncompress_init(&data, NULL, 0);
        data.readSourceByte = &readDeflatedByte;
        data.writeDestByte = &writeInflatedByte;
        data.readDestByte = &readInflatedByte;

        target_flash_unlock();
        target_update_status(STATUS_RUNNING);
        uint8_t* final_flash_page = (uint8_t*)target_get_flash_page_address((uint16_t*)PAYLOAD_TARGET);
        while (flash_write_ptr >= final_flash_page) {            
            size_t bytes_to_inflate = logical_write_ptr - flash_write_ptr + 1;
            TINF_STATUS status = uzlib_uncompress(&data, bytes_to_inflate);
            if (status == TINF_OK) {
                // Check if we still need to backup the destination page first
                const uint8_t* const flash_write_end = flash_write_ptr + FLASH_PAGE_SIZE;
                if ((flash_write_end > deflated_payload_start) &&
                    (flash_write_ptr <= logical_read_ptr)) {
                    
                    size_t bytes_to_save = logical_read_ptr - flash_write_ptr + 1;
                    if (bytes_to_save > FLASH_PAGE_SIZE) {
                        bytes_to_save = FLASH_PAGE_SIZE;
                    }
                    size_t bytes_saved = copy_to_scratch_buffer(flash_write_ptr, bytes_to_save);
                    if (bytes_saved == bytes_to_save) {
                        if (alias_start >= alias_end) {
                            alias_end = flash_write_ptr + bytes_saved + 1;
                        }
                        alias_start = flash_write_ptr;
                    } else {
                        ok = false;
                    }
                }
            } else {
                ok = false;
            }
            if (ok) {
                ok = target_flash_program_array((uint16_t*)flash_write_ptr, (uint16_t*)inflate_buf, (bytes_to_inflate+1)/2);
                if (ok) {
                    flash_write_ptr -= FLASH_PAGE_SIZE;
                }
            }
            
            if (!ok) {
                break;
            }
        }

        if (!ok) {
            // Erase the payload to prevent loops
            target_flash_erase_to_end((uint16_t*)deflated_payload_start);
        }

        target_flash_lock();
    }

    if (ok) {
        const size_t decompressed_size = inflated_payload_end - inflated_payload_start;
        uint32_t decompressed_crc = uzlib_crc32(inflated_payload_start, decompressed_size, 0xFFFFFFFFUL) ^ 0xFFFFFFFFUL;
        if (decompressed_crc != expected_decompressed_crc) {
            ok = false;
        }
    }

    if (ok) {
        target_update_status(STATUS_DONE);
    } else {
        target_update_status(STATUS_ERROR);
    }
    
    target_reset_self();

    while (1);
    
    return 0;
}
